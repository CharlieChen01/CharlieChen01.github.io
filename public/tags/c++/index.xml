<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>C&#43;&#43; on ğŸ‘¨â€ğŸŒ¾ Charlie Chen</title>
    <link>http://localhost:1313/tags/c&#43;&#43;/</link>
    <description>Recent content in C&#43;&#43; on ğŸ‘¨â€ğŸŒ¾ Charlie Chen</description>
    <generator>Hugo -- 0.124.1</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 22 May 2024 16:49:05 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>How to Decode Mp4 Using C&#43;&#43; and Ffmepg</title>
      <link>http://localhost:1313/posts/media/how-to-decode-mp4-using-c&#43;&#43;-and-ffmepg/</link>
      <pubDate>Wed, 22 May 2024 16:49:05 +0800</pubDate>
      <guid>http://localhost:1313/posts/media/how-to-decode-mp4-using-c&#43;&#43;-and-ffmepg/</guid>
      <description>ä½¿ç”¨ FFmpeg åº“æ¥å¤„ç† MP4 ç¼–è§£ç  åˆå§‹åŒ– FFmpeg åœ¨ä½ çš„ C++ é¡¹ç›®ä¸­ï¼Œé¦–å…ˆéœ€è¦åˆå§‹åŒ– FFmpegã€‚ä½ å¯ä»¥è°ƒç”¨ av_register_all() æ¥æ³¨å†Œ FFmpeg æ‰€æœ‰çš„ç¼–è§£ç å™¨å’Œæ ¼å¼ã€‚
æ‰“å¼€è¾“å…¥æ–‡ä»¶ ä½¿ç”¨ avformat_open_input() æ‰“å¼€ MP4 æ–‡ä»¶ï¼Œè·å– AVFormatContext ç»“æ„ä½“ã€‚è¿™ä¸ªç»“æ„ä½“åŒ…å«äº†æ–‡ä»¶çš„æµä¿¡æ¯ã€ç¼–è§£ç å™¨ç­‰ã€‚
æŸ¥æ‰¾è§†é¢‘æµ éå† AVFormatContext ä¸­çš„æµï¼Œæ‰¾åˆ°è§†é¢‘æµçš„ç´¢å¼•ã€‚
è·å–è§†é¢‘è§£ç å™¨ ä½¿ç”¨è§†é¢‘æµç´¢å¼•ï¼Œè·å–è§†é¢‘æµçš„è§£ç å™¨ä¸Šä¸‹æ–‡ AVCodecContextã€‚ä½ å¯ä»¥ä½¿ç”¨ avcodec_find_decoder() æ¥æŸ¥æ‰¾åˆé€‚çš„è§£ç å™¨ã€‚
æ‰“å¼€è§£ç å™¨ ä½¿ç”¨ avcodec_open2() æ‰“å¼€è§£ç å™¨ã€‚
è¯»å–å¸§ ä½¿ç”¨ av_read_frame() è¯»å–è§†é¢‘å¸§ã€‚æ¯ä¸€å¸§éƒ½åŒ…å«åœ¨ AVPacket ä¸­ã€‚
è§£ç å¸§ ä½¿ç”¨ avcodec_decode_video2() è§£ç è§†é¢‘å¸§ã€‚è§£ç åçš„å›¾åƒæ•°æ®å°†å­˜å‚¨åœ¨ AVFrame ä¸­ã€‚
ç¼–ç å¸§ å¦‚æœä½ éœ€è¦é‡æ–°ç¼–ç å¸§ï¼Œå¯ä»¥ä½¿ç”¨ avcodec_encode_video2() å°†è§£ç åçš„å¸§é‡æ–°ç¼–ç ã€‚
ä¿å­˜å¸§ å°†ç¼–ç åçš„å¸§ä¿å­˜åˆ°æ–‡ä»¶ä¸­ã€‚ä½ å¯ä»¥ä½¿ç”¨ av_interleaved_write_frame() å°†å¸§å†™å…¥è¾“å‡ºæ–‡ä»¶ã€‚
æ¸…ç†èµ„æº æœ€åï¼Œåˆ«å¿˜äº†é‡Šæ”¾æ‰€æœ‰åˆ†é…çš„å†…å­˜å’Œå…³é—­æ–‡ä»¶ã€‚
ä»¥ä¸‹æ˜¯ä½¿ç”¨ C++ï¼Œ FFmpeg å¤„ç† MP4 ç¼–è§£ç ç¤ºä¾‹ä»£ç ï¼š
extern &amp;#34;C&amp;#34; { #include &amp;lt;libavformat/avformat.h&amp;gt; #include &amp;lt;libavcodec/avcodec.</description>
    </item>
    <item>
      <title>The Implement of Qos   2</title>
      <link>http://localhost:1313/posts/media/the-implement-of-qos---2/</link>
      <pubDate>Thu, 16 May 2024 15:28:08 +0800</pubDate>
      <guid>http://localhost:1313/posts/media/the-implement-of-qos---2/</guid>
      <description>ä½¿ç”¨ Boost.Asio åº“å®ç° QoSï¼ˆæœåŠ¡è´¨é‡ï¼‰ç­–ç•¥ åœ¨ C++ä¸­ä½¿ç”¨ Boost.Asio åº“æ¥æ§åˆ¶æ•°æ®åŒ…çš„å‘é€å’Œæ¥æ”¶ï¼Œå¹¶å®ç° QoSï¼ˆæœåŠ¡è´¨é‡ï¼‰ç­–ç•¥ï¼Œæ¶‰åŠåˆ°å¯¹ Asio åº“çš„æ·±å…¥ç†è§£å’Œåº”ç”¨ã€‚ ä»¥ä¸‹æ˜¯ä¸€ä¸ªåŸºæœ¬çš„æŒ‡å—ï¼Œå¸®åŠ©ä½ å¼€å§‹ä½¿ç”¨ Boost.Asio æ¥æ§åˆ¶æ•°æ®æµï¼š
å®‰è£… Boost.Asio: ç¡®ä¿ä½ çš„ç³»ç»Ÿå·²ç»å®‰è£…äº† Boost åº“å’Œ Boost.Asio ç»„ä»¶ã€‚
åˆ›å»º io_context å¯¹è±¡: io_context æ˜¯ Asio çš„ä¸­å¿ƒï¼Œæ‰€æœ‰çš„å¼‚æ­¥æ“ä½œéƒ½éœ€è¦é€šè¿‡å®ƒæ¥è¿›è¡Œã€‚
åˆ›å»ºå¥—æ¥å­—: ä½¿ç”¨ tcp::socket æˆ– udp::socket æ¥åˆ›å»ºä¸€ä¸ªå¥—æ¥å­—å¯¹è±¡ï¼Œè¿™å°†ç”¨äºç½‘ç»œé€šä¿¡ã€‚
è¿æ¥å’Œç›‘å¬: å¯¹äºå®¢æˆ·ç«¯ï¼Œä½¿ç”¨ socket.connect()æ¥å»ºç«‹è¿æ¥ã€‚ å¯¹äºæœåŠ¡å™¨ï¼Œä½¿ç”¨ tcp::acceptor æ¥ç›‘å¬ç«¯å£å¹¶æ¥å—è¿æ¥ã€‚
å¼‚æ­¥æ“ä½œ: ä½¿ç”¨ async_readã€async_writeã€async_connect ç­‰å‡½æ•°æ¥æ‰§è¡Œå¼‚æ­¥ I/O æ“ä½œã€‚
å¤„ç†æ•°æ®: ä½¿ç”¨ boost::asio::buffer æ¥åˆ›å»ºç¼“å†²åŒºï¼Œè¿™å°†ç”¨äºè¯»å–æˆ–å†™å…¥æ•°æ®ã€‚
å®ç° QoS ç­–ç•¥: æ ¹æ®ä½ çš„ QoS éœ€æ±‚ï¼Œä½ å¯èƒ½éœ€è¦å®ç°ç‰¹å®šçš„æ•°æ®åŒ…è°ƒåº¦ç­–ç•¥ã€‚ ä¾‹å¦‚ï¼Œä½ å¯ä»¥é€šè¿‡æ§åˆ¶æ•°æ®åŒ…çš„å‘é€é—´éš”æˆ–ä¼˜å…ˆçº§æ¥ç®¡ç†ç½‘ç»œæµé‡ã€‚
é”™è¯¯å¤„ç†: ä½¿ç”¨é”™è¯¯ç æˆ–å¼‚å¸¸æ¥å¤„ç†ç½‘ç»œæ“ä½œä¸­å¯èƒ½å‡ºç°çš„é”™è¯¯ã€‚
è¿è¡Œ io_context: è°ƒç”¨ io_context.run()æ¥å¯åŠ¨äº‹ä»¶å¾ªç¯ï¼Œå¤„ç†æ‰€æœ‰æ’é˜Ÿçš„å¼‚æ­¥äº‹ä»¶ã€‚
ä¸‹é¢æ˜¯ä¸€ä¸ªç®€å•çš„ç¤ºä¾‹ï¼Œå±•ç¤ºå¦‚ä½•ä½¿ç”¨ Boost.Asio å‘é€å’Œæ¥æ”¶æ•°æ®ï¼š
#include &amp;lt;boost/asio.hpp&amp;gt; #include &amp;lt;iostream&amp;gt; using boost::asio::ip::tcp; int main() { try { boost::asio::io_context io_context; // åˆ›å»ºä¸€ä¸ªsocket tcp::socket socket(io_context); tcp::resolver resolver(io_context); boost::asio::connect(socket, resolver.</description>
    </item>
    <item>
      <title>Type Casts in C&#43;&#43;</title>
      <link>http://localhost:1313/posts/c&#43;&#43;/type-casts-in-c&#43;&#43;/</link>
      <pubDate>Tue, 07 May 2024 10:37:11 +0800</pubDate>
      <guid>http://localhost:1313/posts/c&#43;&#43;/type-casts-in-c&#43;&#43;/</guid>
      <description>åœ¨ C++ ä¸­ï¼Œç±»å‹è½¬æ¢æ˜¯ä¸€ä¸ªé‡è¦çš„æ¦‚å¿µï¼Œå°¤å…¶æ˜¯åœ¨å¤„ç†ä¸åŒç±»å‹çš„å¯¹è±¡å’ŒæŒ‡é’ˆæ—¶ã€‚ä»¥ä¸‹æ˜¯å››ç§ C++ ç±»å‹è½¬æ¢è¿ç®—ç¬¦çš„é€‚ç”¨åœºæ™¯ï¼š
static_cast: ç”¨äºåŸºæœ¬æ•°æ®ç±»å‹ä¹‹é—´çš„è½¬æ¢ï¼Œå¦‚å°† int è½¬æ¢ä¸º floatã€‚ ç”¨äºç±»å±‚æ¬¡ç»“æ„ä¸­å‘ä¸Šè½¬å‹ï¼ˆä»æ´¾ç”Ÿç±»æŒ‡é’ˆè½¬æ¢ä¸ºåŸºç±»æŒ‡é’ˆï¼‰ã€‚ å¯ä»¥è°ƒç”¨ç±»å‹çš„æ˜¾å¼è½¬æ¢æ„é€ å‡½æ•°æˆ–è½¬æ¢è¿ç®—ç¬¦ã€‚ ç¤ºä¾‹ï¼š int i = 42; float f = static_cast&amp;lt;float&amp;gt;(i); // å°† int è½¬æ¢ä¸º float reinterpret_cast: ç”¨äºæŒ‡é’ˆç±»å‹ä¹‹é—´çš„è½¬æ¢ï¼Œä½†ä¸æ”¹å˜æŒ‡é’ˆæŒ‡å‘çš„å†…å­˜å†…å®¹ã€‚ å¯ä»¥å°†æŒ‡é’ˆè½¬æ¢ä¸ºè¶³å¤Ÿå¤§çš„æ•´æ•°ç±»å‹ï¼Œåä¹‹äº¦ç„¶ã€‚ é€šå¸¸ç”¨äºåº•å±‚æ“ä½œï¼Œå¦‚æ“ä½œç¡¬ä»¶æˆ–è¿›è¡Œä¸å¹³å°ç›¸å…³çš„è°ƒç”¨ã€‚ ç¤ºä¾‹ï¼š int* p = new int(42); void* v = reinterpret_cast&amp;lt;void*&amp;gt;(p); // å°† int* è½¬æ¢ä¸º void* const_cast: ç”¨äºæ·»åŠ æˆ–ç§»é™¤å¯¹è±¡çš„ const å±æ€§ã€‚ åªèƒ½ç”¨äºç›¸åŒç±»å‹ä¹‹é—´çš„è½¬æ¢ï¼Œä¸èƒ½æ”¹å˜ç±»å‹æœ¬èº«ã€‚ é€šå¸¸ç”¨äºè°ƒç”¨é‚£äº›å‚æ•°ä¸ºé const çš„å‡½æ•°ï¼Œè€Œä½ æœ‰ä¸€ä¸ª const å¯¹è±¡ã€‚ ç¤ºä¾‹ï¼š const int* cp = &amp;amp;i; int* p = const_cast&amp;lt;int*&amp;gt;(cp); // ç§»é™¤ const å±æ€§ dynamic_cast: ä¸»è¦ç”¨äºç±»å±‚æ¬¡ç»“æ„ä¸­çš„å®‰å…¨å‘ä¸‹è½¬å‹ï¼ˆä»åŸºç±»æŒ‡é’ˆè½¬æ¢ä¸ºæ´¾ç”Ÿç±»æŒ‡é’ˆï¼‰ã€‚ åœ¨è½¬æ¢æ— æ•ˆæ—¶ä¼šè¿”å› nullptrï¼Œå› æ­¤æ¯” static_cast æ›´å®‰å…¨ã€‚ éœ€è¦è¿è¡Œæ—¶ç±»å‹ä¿¡æ¯ï¼ˆRTTIï¼‰æ”¯æŒã€‚ ç¤ºä¾‹ï¼š Base* b = new Derived(); Derived* d = dynamic_cast&amp;lt;Derived*&amp;gt;(b); // å®‰å…¨å‘ä¸‹è½¬å‹ åœ¨é€‰æ‹©ä½¿ç”¨å“ªç§ç±»å‹è½¬æ¢æ—¶ï¼Œåº”è€ƒè™‘è½¬æ¢çš„å®‰å…¨æ€§å’Œç›®çš„ã€‚static_cast æ˜¯æœ€å¸¸ç”¨çš„è½¬æ¢ç±»å‹ï¼Œé€‚ç”¨äºå¤§å¤šæ•°éå¤šæ€ç±»å‹è½¬æ¢ã€‚reinterpret_cast æ˜¯æœ€ä¸å®‰å…¨çš„ï¼Œåº”è°¨æ…ä½¿ç”¨ã€‚const_cast é€šå¸¸ç”¨äºç§»é™¤ const å±æ€§ä»¥ä¾¿äºç‰¹å®šå‡½æ•°çš„è°ƒç”¨ã€‚dynamic_cast åœ¨å¤šæ€ç±»å‹è½¬æ¢ä¸­æä¾›äº†ç±»å‹å®‰å…¨æ£€æŸ¥ï¼Œä½†æ€§èƒ½å¼€é”€è¾ƒå¤§ 12345ã€‚</description>
    </item>
    <item>
      <title>Smart Pointers in C&#43;&#43;</title>
      <link>http://localhost:1313/posts/c&#43;&#43;/smart-pointers-in-c&#43;&#43;/</link>
      <pubDate>Tue, 07 May 2024 10:12:55 +0800</pubDate>
      <guid>http://localhost:1313/posts/c&#43;&#43;/smart-pointers-in-c&#43;&#43;/</guid>
      <description>Letâ€™s explore some examples of using std::unique_ptr, std::shared_ptr, and std::weak_ptr in C++.
std::unique_ptr: std::unique_ptr is designed for exclusive ownership of a dynamically allocated object. It ensures that there can be at most one unique_ptr pointing to any resource. When the unique_ptr is destroyed, the resource it points to is automatically reclaimed. You cannot make a copy of a unique_ptr, but you can move it using the new move semantics. Example:</description>
    </item>
  </channel>
</rss>
